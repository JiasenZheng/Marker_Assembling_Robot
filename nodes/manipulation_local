#! /usr/bin/env python

import rospy
import manipulation.trayPositions as tP
from group4.srv import TrayLocationMove, LocationMove, PoseMove, GetPose
from geometry_msgs.msg import Pose, Point, Quaternion, Vector3
from tf_conversions import transformations
import numpy as np


"""
Call a move to each tray location by specifying the tray number and location number and height level

Or could break it out into respective tray services
"""

class LocalManipulationNode():
    def __init__(self):
        self.go_to_trayLocation = rospy.Service("go_to_trayLocation", TrayLocationMove, self.handle_goToTrayLocation)


        ## LATER IF NECESSARY
        # self.go_to_Assemblylocation = rospy.Service("go_to_assemblylocation", LocationMove, self.handle_goToAssemblyLocation)
        # self.go_to_Markerslocation = rospy.Service("go_to_markerslocation", LocationMove, self.handle_goToMarkersLocation)
        # self.go_to_Capslocation = rospy.Service("go_to_capslocation", LocationMove, self.handle_goToCapsLocation)

        self.move_to_pose = rospy.ServiceProxy("pose_move", PoseMove)
        self.get_current_pose = rospy.ServiceProxy("get_arm_pose", GetPose)

        ## The default orientation for all moves, so as to remain vertical in all interaction posiitoins
        self.rpy = [0, 0, np.pi/4] ## will have to change/check the z rotation because of franka's offset
        self.q = transformations.quaternion_from_euler(self.rpy[0], self.rpy[1], self.rpy[1] )
        rospy.loginfo("self.rpy")
        rospy.loginfo(self.rpy)
        rospy.loginfo("self.q")
        rospy.loginfo(self.q)
        

        ## Assembly Tray Parameters

        self.assemblyX = rospy.get_param("/x1")
        self.assemblyY = rospy.get_param("/y1")
        self.assemblyXPitch = rospy.get_param("/pitch_1_x")
        self.assemblyYPitch = rospy.get_param("/pitch_1_y")
        # self.assemblyZStandoff = rospy.get_param("/z1_standoff")
        # self.assemblyZPress = rospy.get_param("/z1_press")
        # self.assemblyZPlace = rospy.get_param("/z1_place")
        self.assemblyZStandoff = 0.26
        self.assemblyZPress = 0.23
        self.assemblyZPlace = 0.2

        ## Marker Tray Parameters

        self.markersX = rospy.get_param("/x2")
        self.markersY = rospy.get_param("/y2")
        self.markersXPitch = rospy.get_param("/pitch_2_x")
        self.markersyYPitch = rospy.get_param("/pitch_2_y")
        # self.markersZStandoff = rospy.get_param("/z2_standoff")
        # self.markersyZPick = rospy.get_param("/z2_pick")
        self.markersZStandoff = 0.26
        self.markersZPick = 0.2

        ## Marker Tray Parameters

        self.capsX = rospy.get_param("/x3")
        self.capsY = rospy.get_param("/y3")
        self.capsXPitch = rospy.get_param("/pitch_3_x")
        self.capsyYPitch = rospy.get_param("/pitch_3_y")
        # self.capsZStandoff = rospy.get_param("/z3_standoff")
        # self.capsyZPick = rospy.get_param("/z3_pick")
        self.capsZStandoff = 0.2
        self.capsZPick = 0.17


        ## Setting up TrayPositions

        self.assemblyTray = tP.TrayPositions(
                            self.assemblyX, self.assemblyY, 
                            self.assemblyXPitch, self.assemblyYPitch,
                            self.assemblyZStandoff, self.assemblyZPlace)

        self.markersTray = tP.TrayPositions(
                            self.markersX, self.markersY, 
                            self.markersXPitch, self.markersyYPitch, 
                            self.markersZStandoff, self.markersZPick)

        self.capsTray = tP.TrayPositions(
                            self.capsX, self.capsY, 
                            self.capsXPitch, self.capsyYPitch, 
                            self.capsZStandoff, self.capsZPick)
    

    def handle_goToTrayLocation(self, req):

        ## xyz coords corresponding to specified tray, location and heightLevel
        if req.trayNumber == 1: ## assembly
            xyz = self.assemblyTray.get_location(req.location, req.heightLevel)
        elif req.trayNumber == 2:  ## markers
            xyz = self.markersTray.get_location(req.location, req.heightLevel)
        elif req.trayNumber == 3: ## caps
            xyz = self.capsTray.get_location(req.location, req.heightLevel)
        rospy.loginfo("xyz: ", xyz)

        ## Build up the pose representations for poseMove and for comparison
        xyzPoint = Point(xyz[0], xyz[1], xyz[2])
        rpyOrientation = Vector3(self.rpy[0], self.rpy[1], self.rpy[2])
        qOrientation = Quaternion(self.q[0], self.q[1], self.q[2], self.q[3])
        targetPose = Pose(xyzPoint, qOrientation)

        ## Command robot to move
        self.move_to_pose(xyzPoint, rpyOrientation)

        ## Verify Completed move
        currentPose = self.get_current_pose().pose
        if self.isPoseClose(targetPose, currentPose):
            success = True
            error_msg = f"Final pose matches the target pose {targetPose}"
        else:
            error_msg = f"[ERROR]: Final pose {currentPose} does not match the target pose {targetPose}"
            success = False

        return success, currentPose, error_msg
        

    ## LATER IF NECESSARY
    # def handle_goToAssemblyLocation(self, req):
    #     pass
    # def handle_goToMarkersLocation(self, req):
    #     pass
    # def handle_goToCapsLocation(self, req):
    #     pass

    def isPoseClose(self, referencePose, currentPose):
        ref = self.poseToArray(referencePose)
        cur = self.poseToArray(currentPose)
        return np.isclose(ref, cur, 0.0015)  ## might need to tweak the tolerance

    def poseToArray(self, pose):
        a1 = pose.point.x
        a2 = pose.point.y
        a3 = pose.point.z
        a4 = pose.orientation.x
        a5 = pose.orientation.y
        a6 = pose.orientation.z
        a7 = pose.orientation.w
        return np.array([a1, a2, a3, a4, a5, a6, a7])

if __name__ == "__main__":
    rospy.init_node("local_manipulation")
    node = LocalManipulationNode()
    rospy.spin()

