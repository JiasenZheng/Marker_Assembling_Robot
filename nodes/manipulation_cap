#!/usr/bin/env python

from os import wait

import rospy

import actionlib
import sys
import moveit_commander
from geometry_msgs.msg import Pose
from std_srvs.srv import Trigger, EmptyResponse, Empty as E
from franka_gripper.msg import MoveAction, GraspAction, HomingAction, \
    StopAction, GraspActionGoal, MoveActionGoal, HomingActionGoal, \
        StopActionGoal, MoveGoal, StopGoal, GraspGoal, HomingGoal, GraspEpsilon
from franka_msgs.msg import ErrorRecoveryActionGoal
from group4.srv import  NamedMove, JointsMove, GripperOpen, GripperClose, PoseMove, GetPose, GetFloatList, GetFloatListResponse, DeltaMove
from numpy import pi
from manipulation.translationUtilities import *



"""
This node provides a series of low level services used in the manipulation portion of the project

Services:
    pose_move of type PoseMove moves the robot to a specific pose
    cartesian_pose_move of type PoseMove moves the robot to a pose using cartesian movements
    joints_move of type JointsMove moves the robot joints to a specifc configuration in degrees with a list of values
    named_move of type Named_Move moves the robot to named pose
    delta_move of type DeltaMove shift the robot arm linearly along an axis
    to_standoff moves the robot to a specific standoff pose
    get_arm_pose of type GetPose returns the the pose of the robot arm
    get_arm_joints of type GetFloatList returns the joint angle values
    get_arm_rpy of type GetFloatList list returns the roll, pitch yaw values of the robot arm
    get_current_gripper_state  of type GetFloatList   


"""

class ManipulationCapNode:
    def __init__(self):

        ## Setting up for moveit "arm" and "hand" control
        self.robot = moveit_commander.RobotCommander()
        self.arm_group_name = "panda_arm"
        self.gripper_group_name = "hand"
        self.arm = moveit_commander.MoveGroupCommander(self.arm_group_name)
        self.gripper = moveit_commander.MoveGroupCommander(self.gripper_group_name)
        
        ## Setting up Services to move the arm
        self.pose_move_service= rospy.Service("pose_move", PoseMove, self.handle_pose_move)
        self.cart_pose_move_service = rospy.Service("cartesian_pose_move", PoseMove, self.handle_cartesian_pose_move)
        self.joints_move_service = rospy.Service("joints_move", JointsMove , self.handle_joints_move)
        self.named_move_service = rospy.Service("named_move", NamedMove, self.handle_named_move)
        self.delta_move_service = rospy.Service("delta_move", DeltaMove, self.handle_delta_move)
        self.to_standoff_service = rospy.Service("to_standoff", E, self.handle_to_standoff)


        ## Querying the robot state
        self.get_arm_pose = rospy.Service("get_arm_pose", GetPose, self.handle_get_arm_pose)
        self.get_arm_joints = rospy.Service("get_arm_joints", GetFloatList, self.handle_get_arm_joints)
        self.get_arm_rpy = rospy.Service("get_arm_rpy", GetFloatList, self.handle_get_arm_rpy)
        self.get_current_gripper_state = rospy.Service("get_gripper_joints", GetFloatList, self.handle_get_gripper_joints)

        ## Setting up Services to actuate gripper
        ## For grasp action dialog: rosrun actionlib_tools axclient.py /franka_gripper/grasp
        ## For move action dialog: rosrun actionlib_tools axclient.py /franka_gripper/move

        self.gripper_grasp_client = actionlib.SimpleActionClient("/franka_gripper/grasp", GraspAction)
        self.gripper_move_client = actionlib.SimpleActionClient("/franka_gripper/move", MoveAction)
        self.gripper_stop_client = actionlib.SimpleActionClient("/franka_gripper/stop", StopAction)
        self.gripper_homing_client = actionlib.SimpleActionClient("/franka_gripper/homing", HomingAction)
        self.gripper_grasp_client.wait_for_server()
        self.gripper_move_client.wait_for_server()
        self.gripper_stop_client.wait_for_server()
        self.gripper_homing_client.wait_for_server()

        self.close_service = rospy.Service("grip", GripperClose, self.handle_gripper_close)
        self.open_service = rospy.Service("release", GripperOpen, self.handle_gripper_open)

        ## Error Recovery
        self.error_recovery_pub = rospy.Publisher('/franka_control/error_recovery/goal',ErrorRecoveryActionGoal,queue_size=10)
        self.error_recovery_service = rospy.Service("error_recovery", E, self.handle_error_recovery)
        

        ## gripping cap parameter
        ## For grasp action dialog: rosrun actionlib_tools axclient.py /franka_gripper/grasp
        ## For move action dialog: rosrun actionlib_tools axclient.py /franka_gripper/move
        self.cap_grip = GraspGoal(width=0.01840, epsilon=GraspEpsilon(0.01, 0.02), speed=0.5, force=5)
        self.cap_release = MoveGoal(width=0.03, speed=0.5)
        self.grip_cap_service = rospy.Service("grip_cap", Trigger, self.grip_cap)
        self.release_cap_service = rospy.Service("release_cap", Trigger, self.release_cap)

    def handle_pose_move(self, req):
        x = req.point.x
        y = req.point.y
        z = req.point.z
        rot_x = req.orientation.x
        rot_y = req.orientation.y
        rot_z = req.orientation.z
        pose = [x, y, z, rot_x, rot_y, rot_z]
        self.arm.set_pose_target(pose)
        self.arm.go(wait=True)
        return "Done"

    def handle_cartesian_pose_move(self, req):
        curPose = self.arm.get_current_pose()
        curPose = curPose.pose
        rospy.loginfo("curPose from cart_pose_move")
        rospy.loginfo(curPose)
        targetPose = Pose(req.point, rpyVec3ToQuaternion(req.orientation))
        rospy.loginfo("targetPose from cart_pose_move")
        rospy.loginfo(targetPose)
        waypoints = [ targetPose]
        eef_step = 0.01
        jump_threshold = 0.1
        path, fraction = self.arm.compute_cartesian_path(waypoints, eef_step, 0.0)
        rospy.loginfo('path')
        rospy.loginfo(path)
        if req.velocityLevel == 0:
            currState = self.arm.get_current_state()
            path = self.arm.retime_trajectory(currState, path, 0.05, 0.05)
            rospy.loginfo('updated path')
            rospy.loginfo(path)
        self.arm.execute(path, wait=True)
        return "Done"

    def handle_joints_move(self, req):
        joint_angles = [i*pi/180  for i in req.joint_angles]
        self.arm.set_joint_value_target(joint_angles)
        self.arm.go(wait=True)
        return "Done"

    def handle_named_move(self, req):
        target= rospy.get_param(req.target, None)
        if target:
            joint_angles = [i*pi/180  for i in target]
            rospy.loginfo(joint_angles)
            self.arm.set_joint_value_target(joint_angles)
            self.arm.go(wait=True)
            return "Done"
        return "Invalid parameter name given"

    def handle_delta_move(self, req):
        self.arm.shift_pose_target(axis=int(req.axis), value=req.val)
        self.arm.go(wait=True)
        return "Done"

    def handle_gripper_open(self, req):
        goal = req.move_goal
        self.gripper_move_client.send_goal(goal)
        self.gripper_move_client.wait_for_result()
        result = self.gripper_move_client.get_result()
        return result.success, result.error

    def handle_gripper_close(self, req):
        goal = req.grasp_goal
        self.gripper_grasp_client.send_goal(goal)
        self.gripper_grasp_client.wait_for_result()
        result = self.gripper_grasp_client.get_result()
        return result.success, result.error

    def handle_error_recovery(self, req):
        goal = ErrorRecoveryActionGoal()
        self.error_recovery_pub.publish(goal)
        return EmptyResponse()

    def handle_to_standoff(self, req):
        rospy.loginfo("current joint vals:")
        rospy.loginfo(self.arm.get_current_joint_values())
        rospy.loginfo("standoff:")
        rospy.loginfo([11/pi, 8/pi, 1/pi, -125/pi, 1/pi, 135/pi, 60/pi])
        self.arm.set_joint_value_target([11*pi/180, 8*pi/180, 1*pi/180, -125*pi/180, 1*pi/180, 135*pi/180, 60*pi/180])
        self.arm.go(wait=True)
        return EmptyResponse()

    def handle_get_arm_pose(self, req):
        current_pose = self.arm.get_current_pose()
        return current_pose

    def handle_get_arm_joints(self, req):
        current_joints = self.arm.get_current_joint_values()
        rospy.loginfo(type(current_joints))
        rospy.loginfo(current_joints)
        return GetFloatListResponse(list(current_joints))

    def handle_get_arm_rpy(self, req):
        current_rpy = self.arm.get_current_rpy()
        return GetFloatListResponse(list(current_rpy))

    def handle_get_gripper_joints(self, req):
        current_joints = self.gripper.get_current_joint_values()
        return list(current_joints)

    def grip_cap(self, req):
        self.gripper_grasp_client.send_goal(self.cap_grip)
        self.gripper_grasp_client.wait_for_result()
        result = self.gripper_grasp_client.get_result()
        return result.success, "Done"

    def release_cap(self, req):
        self.gripper_move_client.send_goal(self.cap_release)
        self.gripper_move_client.wait_for_result()
        result = self.gripper_move_client.get_result()
        return result.success, "Done"

    

if __name__ == "__main__":
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node("man_cap", anonymous=True)
    node = ManipulationCapNode()
    rospy.spin()
