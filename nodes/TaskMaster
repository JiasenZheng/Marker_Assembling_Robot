#!/usr/bin/env python3

# from nodes.manipulation_press import ManipulationPress
import rospy
import smach_ros
import smach
import numpy as np
import moveit_commander
import geometry_msgs.msg
from std_srvs.srv import Empty
from sensor_msgs.msg import Image
from group4.srv import Press, PickNPlace, GotoPos, ImageCapture


#Array of nine values where the index specifies locaition.

# from std_msgs.msg import String
from copy import deepcopy
from manager.manager import manage

box = [False, False]

# def OpenBox(cat):
#     """Returns that the box is open and sets the state of the cat"""
#     return [True, cat]

# def CloseBox():
#     """Resets the box such that its state is unknown"""
#     return box

def createProxy(service, type):
    rospy.wait_for_service(service)
    return rospy.serviceProxy(service, type)


#Rosservice Proxies for Manipulaition
press_down = rospy.ServiceProxy('press', Press)
marker_to_assembly = rospy.ServiceProxy('pnpMarker', PickNPlace)
cap_to_assembly = rospy.ServiceProxy('pnpCap', PickNPlace)
assembly_standoff = rospy.ServiceProxy('go_to_master', GotoPos)
dispose = rospy.ServiceProxy('go_to_disposal', GotoPos)
cap_standoff = rospy.ServiceProxy('go_to_cap', GotoPos)
marker_standoff = rospy.ServiceProxy('go_to_marker', GotoPos)

# #Rosservice Proxies for Perception
takeImage = rospy.ServiceProxy('capture', ImageCapture)

#New Method of calling required services
# press_down = createProxy('press', Press)
# marker_to_assembly = createProxy('pnpMarker', PickNPlace)
# cap_to_assembly = createProxy('pnpCap', PickNPlace)
# assembly_standoff = createProxy('go_to_master', GotoPos)
# dispose = createProxy('go_to_disposal', GotoPos)
# cap_standoff = createProxy('go_to_cap', GotoPos)
# marker_standoff = createProxy('go_to_marker', GotoPos)

# takeImage = createProxy('capture', ImageCapture)

#This finite state machine for the time being is a test.
#Factors I didn't take into consideraition lead me to believe there is another state that I need to add for dictating that
#The next state concerns a different marker.

manager = manage()

genList = manager.genList
search = manager.fullSearch
match = manager.thoroughMatching



#Test Code:

class StandBy(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['input-detected', 'wait'],
                                input_keys = ['changeFlag_input'],
                                output_keys = ['changeFlag_output'])
    def execute(self, userdata):
        rospy.loginfo('Executing state STAND-BY')
        cap_standoff()
        changeList = takeImage(3).data
        changes = search(changeList, 0)
        if len(changes) != 9:
            rospy.loginfo('I detected change.')
            userdata.changeFlag_output = True
        if userdata.changeFlag_input:
            return 'input-detected'
        return 'wait'

class Caps(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['look'],
                            input_keys = ['capList_output'],
                            output_keys = ['capList_output'])
    
    #Things to keep note of incase it causes logic errors down the line
    #I don't know if services output data has to be passed between each state

    def execute(self, userdata):
        rospy.loginfo('Executing state CAPS')
        # cap_standoff()
        userdata.capList_output = takeImage(3).data
        rospy.loginfo(userdata.capList_output)
        #userdata.capList_output.data
        print(type(userdata.capList_output))
        print(userdata.capList_output)
        assembly_standoff()
        return 'look'

class Markers(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['match!'],
                                input_keys = ['markerList_output'],
                                output_keys = ['markerList_output'])

    def execute(self, userdata):
        rospy.loginfo('Executing state MARKERS')
        marker_standoff()
        userdata.markerList_output = takeImage(2).data
        rospy.loginfo(f"Marker List: {userdata.markerList_output}")
        assembly_standoff()
        return 'match!'

class genMatch(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['next?', 'wait'],
                                    input_keys = ['markerList_input', 'capList_input'],
                                    output_keys = ['matchList_output', 'changeFlag_output'])
    def execute(self, userdata):
        rospy.loginfo('Executing state GENERATE-MATCH')
        matchList = match(userdata.capList_input, userdata.markerList_input)
        rospy.loginfo(f"match list: {matchList}")
        if matchList == []:
            rospy.loginfo('Could not find matches going to STAND-BY')
            userdata.changeFlag_output = False
            return 'wait'
        userdata.matchList_output = genList(matchList)
        return 'next?'

class setTarget(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['move!', 'finished'],
                                input_keys = ['matchList_input', 'loc_input'],
                                output_keys=['target_output', 'loc_output', 'changeFlag_output'])
    def execute(self, userdata):
        rospy.loginfo('Executing state SET_TARGET')
        try:
            ____, userdata.target_output = next(userdata.matchList_input)
            rospy.loginfo(f"Current Target: {userdata.target_output}")
            assembly_standoff()
            assemblyLocList = takeImage(1).data
            userdata.loc_output = search(assemblyLocList, 0)[0]
            return 'move!'
        except StopIteration:
            rospy.loginfo('I finished so I am going to STAND-BY')
            userdata.changeFlag_output = False
            return 'finished'

class Assemble(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?'],
                                input_keys = ['target_input', 'loc_input'])
    
    def execute(self, userdata):
        rospy.loginfo('Executing state ASSEMBLE')
        marker_standoff()
        rospy.loginfo('Getting Marker')
        marker_to_assembly(userdata.target_input[1], userdata.loc_input)
        assembly_standoff()
        cap_standoff()
        rospy.loginfo('Getting Caps')
        cap_to_assembly(userdata.target_input[0], userdata.loc_input)
        rospy.loginfo('Finishing')
        press_down(userdata.loc_input)
        return 'Next?'

def starterCallback():
    return

def main():
    rospy.init_node('marker_assymbly_task_master')
    # markers = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    # caps = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    markers = []
    caps = []
    #Create state machine
    sm = smach.StateMachine(outcomes = ['Finished'])
    sm.userdata.changeFlag = True
    sm.userdata.markerList = markers
    sm.userdata.capList = caps
    sm.userdata.matchList = []
    sm.userdata.target = []
    sm.userdata.loc = 3


    
    #Open the container
    with sm:

        smach.StateMachine.add('STAND-BY', StandBy(), 
                                transitions = {
                                    'input-detected':'CAPS', 
                                    'wait':'STAND-BY'
                                }, remapping = {
                                    'changeFlag_input':'changeFlag',
                                    'changeFlag_output':'changeFlag'
                                })

        smach.StateMachine.add('CAPS', Caps(), 
                                transitions = {
                                    'look':'MARKERS'
                                }, remapping = {
                                    'capList_input':'capList',
                                    'capList_output':'capList'
                                })
    
        smach.StateMachine.add('MARKERS', Markers(),
                                transitions = {
                                    'match!':'GENERATE-MATCHES'
                                }, remapping = {
                                    'markerList_input':'markerList',
                                    'markerList_output':'markerList'
                                })

        smach.StateMachine.add('GENERATE-MATCHES', genMatch(),
                                transitions = {
                                    'next?':'SET-TARGET', 
                                    'wait':'STAND-BY'
                                }, remapping = {
                                    'markerList_input':'markerList', 
                                    'capList_input':'capList', 
                                    'matchList_output':'matchList',
                                    'changeFlag_output':'changeFlag'
                                })

        smach.StateMachine.add('SET-TARGET', setTarget(), 
                                transitions = {
                                    'move!':'ASSEMBLE', 
                                    'finished':'STAND-BY'
                                }, remapping = {
                                    'matchList_input':'matchList',
                                    'loc_input':'loc',
                                    'target_output':'target',
                                    'loc_output':'loc',
                                    'changeFlag_output':'changeFlag'
                                })
    
        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions = {
                                    'Next?':'SET-TARGET',
                                }, remapping = {
                                    'target_input':'target', 
                                    'loc_input':'loc'
                                })



    # start = rospy.Service('start', Empty, starterCallback)

    # sis = smach_ros.IntrospectionServer('TaskMaster', sm, '/SM_ROOT')
    # sis.start()

    outcome = sm.execute()

    rospy.spin()
    # sis.stop()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInitException:
        pass