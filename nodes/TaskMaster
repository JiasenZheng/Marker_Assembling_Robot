#!/usr/bin/env python3

import rospy
import smach_ros
import smach
import numpy as np
import moveit_commander
import geometry_msgs.msg

# from std_msgs.msg import String
from copy import deepcopy
# from match.match import match

#This finite state machine for the time being is a test.
#Factors I didn't take into consideraition lead me to believe there is another state that I need to add for dictating that
#The next state concerns a different marker.

def match():
    return True

def search(input):
    return input

class lookProcedure(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['match', 'markerChanged', 'noMarkerChanged', 'capChanged', 'noCapChanged'],
                                input_keys = ['item_input'])

    def execute(self, userdata):
        rospy.loginfo('Executing state LOOK_PROCEDURE')
        if userdata.item_input == 2:
            return 'match'
        if userdata.item_input == 0:
            if match():
                return 'noMarkerChanged'
            else: 
                return 'markerChanged'
        else:
            if match():
                return 'capChanged'
            else: 
                return 'noCapChanged'

class NavigateToMarker(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['change?'], output_keys = ['item_output'])
    
    def execute(self, userdata):
        rospy.loginfo('Executing State NAVIGATE_TO_MARKER')
        userdata.item_output = 0
        return 'change?'

class Move_Marker(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['To_Input', 'To_Assymbly', 'ignore'], input_keys = ['at_input'], output_keys = ['at_output'])
    
    def execute(self, userdata):
        rospy.loginfo('Executing state MOVE_MARKER')
        if userdata.at_input == 0:
            userdata.at_output = 1
            return 'To_Assymbly'
        else:
            if userdata.at == 1:
                userdata.at_output = 0
                return 'To_Input'
            else:
                return 'ignore'


class Navigate_To_Cap(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['change?'], output_keys = ['item_output'])

    def execute(self, userdata):
        rospy.loginfo('Executing State NAVIGATE_TO_CAP')
        userdata.item_output = 1
        return 'change?'

class Find_New_Match(smach.State):

    def __init__(self):
        smach.State.__init__(self, outcomes=['success', 'failure'])

    def execute(self, userdata):
        rospy.loginfo('Executing State FIND_NEW_MATCH')
        # userdata.item_input = 1
        if search(True):
            return 'success'
        else:
            return 'failure'

class Assemble(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Done'])
    
    def execute(self, userdata):
        rospy.loginfo('Executing State ASSEMBLE')
        return 'Done'


def main():
    rospy.init_node('marker_assymbly_task_master')

    #Create state machine
    sm = smach.StateMachine(outcomes = ['Finished'])
    sm.userdata.item = 2
    #input: 0
    #Assymbly: 1
    sm.userdata.at = 0


    #Open the container
    with sm:
        smach.StateMachine.add('LOOK_PROCEDURE', lookProcedure(), 
                                transitions= {
                                    'match':'NAVIGATE_TO_MARKER',
                                    'markerChanged':'NAVIGATE_TO_MARKER',
                                    'noMarkerChanged':'MOVE_MARKER',
                                    'capChanged':'FIND_NEW_MATCH',
                                    'noCapChanged':'ASSEMBLE'},                            
                                    remapping = {
                                    'item_input':'item'
                                })


        smach.StateMachine.add('NAVIGATE_TO_MARKER', NavigateToMarker(),
                                transitions={'change?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })

        smach.StateMachine.add('MOVE_MARKER', Move_Marker(),
                                transitions={
                                    'ignore':'LOOK_PROCEDURE',
                                    'To_Assymbly':'NAVIGATE_TO_CAP',
                                    'To_Input':'LOOK_PROCEDURE'},
                                remapping = {
                                    'at_input':'at',
                                    'at_output':'at'
                                    })
        
        smach.StateMachine.add('NAVIGATE_TO_CAP', Navigate_To_Cap(),
                                transitions={'change?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })
        
        smach.StateMachine.add('FIND_NEW_MATCH', Find_New_Match(),
                                transitions={
                                    'success':'ASSEMBLE', 
                                    'failure':'MOVE_MARKER'})
        
        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions={'Done':'Finished'}
        )
    
    sis = smach_ros.IntrospectionServer('TaskMaster', sm, '/SM_ROOT')
    sis.start()

    outcome = sm.execute()

    rospy.spin()
    sis.stop()

if __name__ == '__main__':
    main()