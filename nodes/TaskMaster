#!/usr/bin/env python3

import rospy
import smach_ros
import smach
import numpy as np
import moveit_commander
import geometry_msgs.msg

#Array of nine values where the index specifies locaition.

# from std_msgs.msg import String
from copy import deepcopy
from match import match
from schrodinger import cat

#This finite state machine for the time being is a test.
#Factors I didn't take into consideraition lead me to believe there is another state that I need to add for dictating that
#The next state concerns a different marker.

# markers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# caps = [1, 2, 3, 4, 5, 6, 7, 8, 9]

#Test Code:
def Foo():
    return ['v']

def Caz():
    return

def Faz(x):
    return x

def Fuz(x, y):
    return True

def match():
    return True

def search(input):
    return input

#Manipulaition Services
Marker_standoff = Foo
Cap_standoff = Foo
PickUp = Faz

#OpenCV Services
GetImage = Caz
ParseData = Faz

#Python Packages: 
TargetSearch = Fuz
Match = Fuz

class StandBy(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Input_Detected', 'Wait'],
                                input_keys = ['Change'])
    def execute(self, userdata):
        rospy.loginfo('Executing state RESTART')
        if userdata.ChangeFlag:
            return 'Look'
        return 'wait'

class Markers(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?'],
                            output_keys = ['MarkerData'])
    
    #Things to keep note of incase it causes logic errors down the line
    #I don't know if services output data has to be passed between each state

    def execute(self, userdata):
        Marker_standoff()
        userdata.MarkerData = match.genMatch(ParseData(GetImage()))
        return 'Next'

class setTarget(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['To-Assembly', 'Finished'],
                                input_keys = ['TargetList'],
                                output_keys=['Target'])
    def execute(self, userdata):
        rospy.loginfo('Executing state SET_TARGET')
        userdata.Target = next(userdata.TargetList)
        return 'To-Assembly'
        return 'Finished'

class Move(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['HaveTarget?', 'To-Input', 'Assemble'],
                                input_keys = ['Target','HaveTarget'])
    
    def execute(self, userdata):
        rospy.loginfo('Executing state MOVE')
        if userdata.HaveTarget[0]:
            return 'HaveTarget?'
        else:
            if userdata.HaveTarget[1]:
                userdata.HaveTarget.CloseBox()
                return 'Assemble'
            else:
                userdata.HaveTarget.CloseBox()
                return 'To-Input'

class Caps(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Result'],
                                input_keys = ['Target'],
                                output_keys = ['HaveTarget'])

    def execute(self, userdata):
        userdata.HaveTarget.OpenBox(True)
        return 'Result'

class Complete(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?'])
    def execute(self, userdata):
        rospy.loginfo('Executing state ASSEMBLE')
        return 'Next?'


def main():
    rospy.init_node('marker_assymbly_task_master')

    #Create state machine
    sm = smach.StateMachine(outcomes = ['Finished'])
    sm.userdata.list = []
    sm.userdata.changeFlag = True
    sm.userdata.loc = 0
    sm.userdata.have = cat
    sm.userdata.obj = None
    sm.userdata.index = 0
    
    #Open the container
    with sm:
        smach.StateMachine.add('STAND-BY', StandBy(), 
                                transitions = {
                                    'Input_Detected':'MARKERS',
                                    'wait':'StandBy'
                                }, remapping = {
                                    'Change':'changeFlag'
                                })

        smach.StateMachine.add('MARKERS', Markers(), 
                                transitions = {
                                    'Next?':'SET_TARGET'
                                }, remapping = {
                                    'MarkerData':'list'
                                })

        smach.StateMachine.add('SET_TARGET', setTarget(), 
                                transitions = {
                                    'finished':'STAND-BY',
                                    'To-Assembly':'MOVE'
                                }, remapping = {
                                    'TargetList':'list',
                                    'Target':'obj'
                                })

        smach.StateMachine.add('MOVE', Move(), 
                                transitions = {
                                    'HaveTarget?':'CAPS',
                                    'To-Input':'RESTART',
                                    'assemble':'COMPLETE'
                                }, remapping = {
                                    'Target':'obj',
                                    'HaveTarget':'have'
                                })
        
        smach.StateMachine.add('CAPS', Caps(),
                                transitions = {
                                    'Next?':'SET_TARGET',
                                    'Answer':'CHECK'
                                }, remapping = {
                                    'Target':'obj',
                                    'HaveTarget':'have'
                                })
        smach.StateMachine.add('COMPLETE', Complete(),
                                transitions = {
                                    'Next?':'SET-TARGET'
                                })



        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions = {
                                    'Next?':'SET-TARGET'
                                }, remapping = {})

        smach.StateMachine.add('LOOK_PROCEDURE', lookProcedure(), 
                                transitions= {
                                    'match':'NAVIGATE_TO_MARKER',
                                    'markerChanged':'NAVIGATE_TO_MARKER',
                                    'noMarkerChanged':'MOVE_MARKER',
                                    'capChanged':'FIND_NEW_MATCH',
                                    'noCapChanged':'ASSEMBLE'},                            
                                    remapping = {
                                    'item_input':'item'
                                })


        smach.StateMachine.add('NAVIGATE_TO_MARKER', NavigateToMarker(),
                                transitions={'HaveTarget?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })

        smach.StateMachine.add('MOVE_MARKER', Move_Marker(),
                                transitions={
                                    'ignore':'LOOK_PROCEDURE',
                                    'To_Assymbly':'NAVIGATE_TO_CAP',
                                    'To_Input':'LOOK_PROCEDURE'},
                                remapping = {
                                    'at_input':'at',
                                    'at_output':'at'
                                    })
        
        smach.StateMachine.add('NAVIGATE_TO_CAP', Navigate_To_Cap(),
                                transitions={'HaveTarget?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })
        
        smach.StateMachine.add('FIND_NEW_MATCH', Find_New_Match(),
                                transitions={
                                    'success':'ASSEMBLE', 
                                    'failure':'MOVE_MARKER'})
        
        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions={'Done':'Finished'}
        )
    
    sis = smach_ros.IntrospectionServer('TaskMaster', sm, '/SM_ROOT')
    sis.start()

    outcome = sm.execute()

    rospy.spin()
    sis.stop()

if __name__ == '__main__':
    main()