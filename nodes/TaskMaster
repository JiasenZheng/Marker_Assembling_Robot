#!/usr/bin/env python3

import rospy
import smach_ros
import smach
import numpy as np
import moveit_commander
import geometry_msgs.msg

# from std_msgs.msg import String
from copy import deepcopy
from match import match

#This finite state machine for the time being is a test.
#Factors I didn't take into consideraition lead me to believe there is another state that I need to add for dictating that
#The next state concerns a different marker.

#Test Code:
def Foo():
    return

def Caz():
    return

def Faz(x):
    return x

def Fuz(x, y):
    return True

def match():
    return True

def search(input):
    return input

#Manipulaition Services
Marker_standoff = Foo

#OpenCV Services
GetImage = Caz
ParseData = Faz

#Python Packages: 
Search = Fuz
Match = Fuz


class Restart(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Look'],
                                output_keys = ['cf_output'])
    def execute(self, userdata):
        rospy.loginfo('Executing state RESTART')
        userdata.cf_output = False
        return 'Look'

class Markers(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Look', 'Answer'],
                            input_keys = ['CheckFlag', 'TargetMarker'],
                            output_keys = ['MarkerData', 'TargetFlag'])
    
    #Things to keep note of incase it causes logic errors down the line
    #I don't know if services output data has to be passed between each state

    def execute(self, userdata):
        rospy.loginfo('Executing state MARKERS')
        Marker_standoff()
        data = GetImage()
        if userdata.CheckFlag:
            if search(userdata.TargetMarker, data):
                userdata.TargetFlag = True
            else: userdata.TargetFlag = False
            return 'Answer'
        userdata.MarkerData = ParseData(data)
        return 'Look'

class Caps(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?', 'Answer'],
                                input_keys = ['CheckFlag', 'TargetCap', 'MarkerData'],
                                output_keys = ['CapData', 'TargetFlag', 'TargetList'])

    def execute(self, userdata):
        rospy.loginfo('Executing state CAPS')
        Marker_standoff()
        data = GetImage()
        if userdata.CheckFlag:
            if search(userdata.TargetCap, data):
                userdata.TargetFlag = True
            else: userdata.TargetFlag = False
            return 'Answer'
        userdata.MarkerData = ParseData(data)
        userdata.TargetList = match.genMatch(match(userdata.MarkerData, userdata.CapData))
        return 'Next?'

class setTarget(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?'],
                                input_keys = [])
    def execute(self, userdata):
        rospy.loginfo('Executing state SET_TARGET')
        
        return 'HaveTarget?'

class Check(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['MarkerTarget?', 'CapTarget?', 'HaveTarget', 'CapTargetMissing', 'HaveTarget', 'Reset'],
                                input_keys = [])
    def execute(self, userdata):
        rospy.loginfo('Executing state CHECK')
        return 'MarkerTarget?'
        return 'Reset'
        return 'HaveTarget'
        return 'CapTarget?'
        return 'CapTargetMissing'
        return 'HaveTarget'

class Search(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Result'],
                            input_keys = [])

class Move(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['HaveTarget?', 'To-Input', 'To-Assemble'],
                                input_keys = [])
    def execute(self, userdata):
        rospy.loginfo('Executing state MOVE')
        return 'HaveTarget?'
        return 'To-Input'
        return 'To-Assymbly'

class Assemble(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['Next?'],
                                input_keys = [])
    def execute(self, userdata):
        rospy.loginfo('Executing state ASSEMBLE')
        return 'Next?'


def main():
    rospy.init_node('marker_assymbly_task_master')

    #Create state machine
    sm = smach.StateMachine(outcomes = ['Finished'])
    sm.userdata.item = 2
    #input: 0
    #Assymbly: 1
    sm.userdata.at = 0
    sm.userdata.CheckFlag = False
    sm.userdata.


    #Open the container
    with sm:
        smach.StateMachine.add('RESET', Restart(), 
                                transitions = {
                                    'Look':'MARKERS'
                                }, remapping = {})

        smach.StateMachine.add('MARKERS', Markers(), 
                                transitions = {
                                    'Look':'CAPS',
                                    'Answer':'CHECK'
                                }, remapping = {})

        smach.StateMachine.add('CAPS', Caps(), 
                                transitions = {
                                    'Next?':'SET_TARGET',
                                    'Answer':'CHECK'
                                }, remapping = {})

        smach.StateMachine.add('SET_TARGET', setTarget(), 
                                transitions = {
                                    'HaveTarget?':'CHECK'
                                }, remapping = {})

        smach.StateMachine.add('CHECK', Check(), 
                                        transitions = {
                                            'MarkerTarget?':'MARKERS',
                                            'CapTarget?':'CAPS',
                                            'HaveTarget':'MOVE',
                                            'CapTargetMissing':'SEARCH',
                                            'Reset':'RESTART'
                                        }, remapping = {})

        smach.StateMachine.add('SEARCH', Search(), 
                                        transitions = {
                                            'result':'MOVE'
                                        }, remapping = {})

        smach.StateMachine.add('MOVE', Move(), 
                                transitions = {
                                    'To-Input':'RESTART',
                                    'To-Assymbly':'ASSEMBLE'
                                }, remapping = {})

        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions = {
                                    'Next?':'SET-TARGET'
                                }, remapping = {})

        smach.StateMachine.add('LOOK_PROCEDURE', lookProcedure(), 
                                transitions= {
                                    'match':'NAVIGATE_TO_MARKER',
                                    'markerChanged':'NAVIGATE_TO_MARKER',
                                    'noMarkerChanged':'MOVE_MARKER',
                                    'capChanged':'FIND_NEW_MATCH',
                                    'noCapChanged':'ASSEMBLE'},                            
                                    remapping = {
                                    'item_input':'item'
                                })


        smach.StateMachine.add('NAVIGATE_TO_MARKER', NavigateToMarker(),
                                transitions={'HaveTarget?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })

        smach.StateMachine.add('MOVE_MARKER', Move_Marker(),
                                transitions={
                                    'ignore':'LOOK_PROCEDURE',
                                    'To_Assymbly':'NAVIGATE_TO_CAP',
                                    'To_Input':'LOOK_PROCEDURE'},
                                remapping = {
                                    'at_input':'at',
                                    'at_output':'at'
                                    })
        
        smach.StateMachine.add('NAVIGATE_TO_CAP', Navigate_To_Cap(),
                                transitions={'HaveTarget?':'LOOK_PROCEDURE'},
                                remapping = {
                                    'item_output':'item'
                                })
        
        smach.StateMachine.add('FIND_NEW_MATCH', Find_New_Match(),
                                transitions={
                                    'success':'ASSEMBLE', 
                                    'failure':'MOVE_MARKER'})
        
        smach.StateMachine.add('ASSEMBLE', Assemble(), 
                                transitions={'Done':'Finished'}
        )
    
    sis = smach_ros.IntrospectionServer('TaskMaster', sm, '/SM_ROOT')
    sis.start()

    outcome = sm.execute()

    rospy.spin()
    sis.stop()

if __name__ == '__main__':
    main()